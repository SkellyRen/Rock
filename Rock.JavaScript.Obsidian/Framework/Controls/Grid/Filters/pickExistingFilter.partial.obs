<template>
    <div class="grid-filter-popup-body">
        <DropDownList v-model="searchMethod"
                      inputClasses="mb-2"
                      :showBlankItem="false"
                      :items="searchTypeItems" />

        <TextBox label="Search"
                 v-model="searchValue" />

        <div v-for="value in displayedValues" class="d-flex align-items-center mb-2">
            <label class="checkbox-inline">
                <input type="checkbox" :checked="value.selected" @change="onSelected(value, $event)" />
                <span class="label-text">&nbsp;</span>
            </label>
            <component :is="column.condensedComponent" :row="value.row" :column="column" />
        </div>
    </div>
</template>

<script setup lang="ts">
    import DropDownList from "@Obsidian/Controls/dropDownList";
    import TextBox from "@Obsidian/Controls/textBox";
    import { PickExistingFilterMethod, PickExistingFilterMethodDescription } from "@Obsidian/Enums/Controls/Grid/pickExistingFilterMethod";
    import { deepEqual } from "@Obsidian/Utility/util";
    import { ref, watch, computed } from "vue";
    import { standardFilterProps } from "@Obsidian/Core/Controls/grid";
    import { ListItemBag } from "@Obsidian/ViewModels/Utility/listItemBag";

    const props = defineProps(standardFilterProps);

    const emit = defineEmits<{
        (e: "update:modelValue", value: unknown): void
    }>();

    type PickExistingSearchBag = {
        method: PickExistingFilterMethod;

        value?: unknown[];
    };

    type DistinctValue = {
        row: Record<string, unknown>;

        sortValue?: string | number;

        quickFilterValue: string;

        filterValue: unknown;

        selected: boolean
    };

    const distinctValues = getDistinctValues();
    const searchMethod = ref(PickExistingFilterMethod.Any.toString());
    const searchValue = ref("");

    const searchTypeItems = ref<ListItemBag[]>(Object.keys(PickExistingFilterMethodDescription).map(n => {
        return {
            value: n,
            text: PickExistingFilterMethodDescription[n]
        };
    }));

    const displayedValues = computed((): DistinctValue[] => {
        let values = distinctValues;

        if (searchValue.value) {
            const lowerSearchValue = searchValue.value.toLowerCase();

            values = values.filter(v => v.quickFilterValue.includes(lowerSearchValue));
        }

        return values.slice(0, 50);
    });

    function getDistinctValues(): DistinctValue[] {
        const valueRows: Record<string | number, DistinctValue> = {};
        const field = props.column.field;
        const rows = props.grid.rows;

        if (!field) {
            return [];
        }

        for (let i = 0; i < rows.length; i++) {
            const value = props.column.uniqueValue(rows[i], props.column, props.grid);

            if (value && valueRows[value] === undefined) {
                const quickFilterValue = props.column.quickFilterValue(rows[i], props.column, props.grid) ?? "";
                let filterValue = props.column.filterValue(rows[i], props.column, props.grid);

                if (filterValue === undefined) {
                    continue;
                }

                valueRows[value] = {
                    row: rows[i],
                    selected: false,
                    sortValue: props.column.sortValue?.(rows[i], props.column, props.grid) ?? "",
                    quickFilterValue: quickFilterValue.toLowerCase(),
                    filterValue
                };
            }
        }

        return Object.values(valueRows);
    }

    function onSelected(value: DistinctValue, event: Event): void {
        const selected = (event.target as HTMLInputElement).checked;

        if (value.selected !== selected) {
            value.selected = selected;

            updateModelValue();
        }
    }

    function updateModelValue(): void {
        const values: unknown[] = [];

        if (props.column.field) {
            for (const value of distinctValues) {
                if (value.selected) {
                    values.push(props.column.filterValue(value.row, props.column, props.grid));
                }
            }
        }

        const searchBag: PickExistingSearchBag = {
            method: Number(searchMethod.value) as PickExistingFilterMethod,
            value: values
        };

        emit("update:modelValue", values.length > 0 ? searchBag : undefined);
    }

    function updateSearchValues(): void {
        if (props.modelValue && typeof props.modelValue === "object") {
            const modelSearchBag = props.modelValue as Partial<PickExistingSearchBag>;

            if (!Array.isArray(modelSearchBag.value) || !props.column.field) {
                for (const value of distinctValues) {
                    value.selected = false;
                }

                return;
            }

            if (modelSearchBag.method !== undefined) {
                searchMethod.value = modelSearchBag.method.toString();

                for (const value of distinctValues) {
                    value.selected = modelSearchBag.value.some(mv => deepEqual(mv, value.filterValue, true));
                }

                return;
            }
        }

        searchMethod.value = PickExistingFilterMethod.Any.toString();
        for (const value of distinctValues) {
            value.selected = false;
        }
    }

    watch(() => props.modelValue, () => updateSearchValues());
    watch([searchMethod, searchValue], () => updateModelValue());

    updateSearchValues();
</script>
