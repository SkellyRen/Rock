<template>
    <th ref="columnHeaderElement" class="grid-column-header" :class="additionalHeaderClass">
        <component v-if="column.headerComponent" :is="column.headerComponent" :column="column" :grid="grid" />
        <span v-else :class="titleClass" @click.prevent="onSortClick">{{ column.title }}</span>

        <span v-if="isSortAscending" class="grid-sort-direction"><i class="fa fa-sort-alpha-up"></i></span>
        <span v-else-if="isSortDescending" class="grid-sort-direction"><i class="fa fa-sort-alpha-down"></i></span>

        <button v-if="isFilterVisible"
                ref="filterButtonElement"
                :class="filterButtonCssClass"
                @click.prevent="onFilterClick">
            <i class="fa fa-filter "></i>
        </button>

        <div v-if="isFilterOpen" ref="filterElement" class="grid-filter-popup">
            <div class="grid-filter-popup-content">
                <component :is="column.filter!.component" v-model="internalFilterValue" :column="column" :grid="grid" />
            </div>

            <div class="actions">
                <button class="btn btn-primary btn-sm" @click.prevent="onFilterApplyClick">Apply</button>
                <button class="btn btn-link btn-sm" @click.prevent="onFilterClearClick">Clear</button>
            </div>
        </div>
    </th>
</template>

<script setup lang="ts">
    import { useVModelPassthrough } from "@Obsidian/Utility/component";
    import { computed, nextTick, PropType, ref, watch } from "vue";
    import { ColumnDefinition, IGridState } from "@Obsidian/Types/Controls/grid";

    const props = defineProps({
        /** The currently selected filter value for the column. */
        filterValue: {
            type: Object as PropType<unknown>,
            required: false
        },

        /** -1 means descending, 1 means ascending, 0 means no sort applied. */
        sortDirection: {
            type: Number as PropType<number>,
            default: 0
        },

        /** The column that should be displayed. */
        column: {
            type: Object as PropType<ColumnDefinition>,
            required: true
        },

        /** The grid state representing the entire grid. */
        grid: {
            type: Object as PropType<IGridState>,
            required: true
        }
    });

    const emit = defineEmits<{
        (event: "update:filterValue", value: unknown | undefined): void,
        (event: "update:sortDirection", value: number): void
    }>();

    // #region Values

    const internalFilterValue = ref(props.filterValue);
    const sortDirection = useVModelPassthrough(props, "sortDirection", emit);
    const isFilterOpen = ref(false);
    const filterElement = ref<HTMLElement | null>(null);
    const filterButtonElement = ref<HTMLElement | null>(null);
    const columnHeaderElement = ref<HTMLElement | null>(null);

    // #endregion

    // #region Computed Values

    /** Will be `true` if we have a filter and it should be visible. */
    const isFilterVisible = computed((): boolean => {
        return props.column.filter !== undefined && isFilteringEnabled.value;
    });

    /** Will be `true` if sorting is enabled on the grid. */
    const isSortingEnabled = computed((): boolean => {
        // Sorting is not supported if re-ordering is enabled.
        return !props.grid.columns.some(c => c.name === "__reorder");
    });

    /** Will be `true` if filtering is enabled on the grid. */
    const isFilteringEnabled = computed((): boolean => {
        // Filtering is not supported if re-ordering is enabled.
        return !props.grid.columns.some(c => c.name === "__reorder");
    });

    /** The CSS classes to apply to the filter button */
    const filterButtonCssClass = computed((): string => {
        return internalFilterValue.value !== undefined
            ? "btn-grid-column-filter active"
            : "btn-grid-column-filter";
    });

    /**
     * Will be `true` if the sort direction is ascending.
     */
    const isSortAscending = computed((): boolean => {
        return sortDirection.value > 0 && isSortingEnabled.value;
    });

    /**
     * Will be `true` if the sort direction is descending.
     */
    const isSortDescending = computed((): boolean => {
        return sortDirection.value < 0 && isSortingEnabled.value;
    });

    /**
     * Additional CSS classes that should be applied to the header.
     */
    const additionalHeaderClass = computed((): string => {
        let classes = props.column.headerClass ?? "";

        if (["sm", "md", "lg", "xl"].includes(props.column.visiblePriority)) {
            // We don't have support for lg just yet, but it's coming.
            if (props.column.visiblePriority === "xl") {
                classes += ` d-none d-lg-table-cell`;
            }
            else {
                classes += ` d-none d-${props.column.visiblePriority}-table-cell`;
            }
        }

        return classes.trim();
    });

    /** The CSS classes that should be applied to the title element. */
    const titleClass = computed((): string => {
        let classValue = "grid-column-title";

        if (isSortingEnabled.value) {
            classValue += " clickable";
        }

        return classValue;
    });

    // #endregion

    // #region Event Handlers

    /**
     * Called whenever the mouse is clicked down anywhere on the page. This is
     * used to automatically close the filter popup if the click wasn't inside
     * the popup somewhere.
     *
     * @param ev The mouse event that triggered this call.
     */
    const onMouseDownEvent = (ev: MouseEvent): void => {
        if (ev.target && ev.target instanceof HTMLElement) {
            if (filterElement.value && filterElement.value.contains(ev.target)) {
                return;
            }

            if (filterButtonElement.value && filterButtonElement.value.contains(ev.target)) {
                return;
            }
        }

        isFilterOpen.value = false;
        internalFilterValue.value = props.filterValue;
    };

    /**
     * Called when the filter icon in the cell header is clicked.
     */
    const onFilterClick = (): void => {
        isFilterOpen.value = !isFilterOpen.value;
    };

    /**
     * Called when the "clear" button inside the filter popup is clicked.
     */
    const onFilterClearClick = (): void => {
        isFilterOpen.value = false;
        internalFilterValue.value = undefined;
        emit("update:filterValue", internalFilterValue.value);
    };

    /**
     * Called when the "apply" button inside the filter popup is clicked.
     * Close the popup and apply the filter value to the grid.
     */
    const onFilterApplyClick = (): void => {
        isFilterOpen.value = false;
        emit("update:filterValue", internalFilterValue.value);
    };

    /**
     * Called when the sort icon in the column header is clicked.
     */
    const onSortClick = (): void => {
        if (!isSortingEnabled.value) {
            return;
        }

        // Toggle the filtering direction.
        if (sortDirection.value > 0) {
            sortDirection.value = -1;
        }
        else {
            sortDirection.value = 1;
        }
    };

    // #endregion

    // Whenever the filter is open, register our mouse down event listener
    // on the whole document. When the filter closes, remove the listener.
    watch(isFilterOpen, () => {
        if (isFilterOpen.value) {
            document.addEventListener("mousedown", onMouseDownEvent);

            nextTick(() => {
                // TODO: Make filter components do default focus.
                // Hack until this is handled by a filter component.
                filterElement.value?.querySelector("input")?.focus();
            });
        }
        else {
            document.removeEventListener("mousedown", onMouseDownEvent);
        }
    });
</script>
