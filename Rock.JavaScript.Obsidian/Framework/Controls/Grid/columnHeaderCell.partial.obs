<template>
    <th ref="columnHeaderElement" class="grid-column-header" :class="additionalHeaderClass">
        <component v-if="column.headerTemplate" :is="column.headerTemplate" :column="column" :grid="grid" />
        <span v-else :class="titleClass" @click.prevent="onSortClick">{{ column.title }}</span>

        <span v-if="isSortAscending" class="grid-sort-direction"><i class="fa fa-sort-alpha-up"></i></span>
        <span v-else-if="isSortDescending" class="grid-sort-direction"><i class="fa fa-sort-alpha-down"></i></span>

        <button v-if="hasFilter"
                ref="filterButtonElement"
                :class="buttonCssClass"
                @click.prevent="onFilterClick">
            <i class="fa fa-filter "></i>
        </button>

        <div v-if="false" ref="resizeHandleElement" class="resize-handle"></div>

        <div v-if="isFilterVisible" ref="filterElement" class="grid-filter-popup">
            <div class="grid-filter-popup-content">
                <component :is="column.filter!.component" v-model="internalFilterValue" :column="column" :rows="rows" :grid="grid" />
            </div>

            <div class="actions">
                <button class="btn btn-primary btn-sm" @click.prevent="onFilterApplyClick">Apply</button>
                <button class="btn btn-link btn-sm" @click.prevent="onFilterClearClick">Clear</button>
            </div>
        </div>
    </th>
</template>

<script setup lang="ts">
    import { useVModelPassthrough } from "@Obsidian/Utility/component";
    import { computed, nextTick, PropType, ref, watch } from "vue";
    import { ColumnDefinition, IGridState } from "@Obsidian/Types/Controls/grid";

    const props = defineProps({
        filterValue: {
            type: Object as PropType<unknown>,
            required: false
        },

        /** -1 means descending, 1 means ascending, 0 means no sort applied. */
        sortDirection: {
            type: Number as PropType<number>,
            default: 0
        },

        column: {
            type: Object as PropType<ColumnDefinition>,
            required: true
        },

        rows: {
            type: Array as PropType<ReadonlyArray<Record<string, unknown>>>,
            required: true
        },

        grid: {
            type: Object as PropType<IGridState>,
            required: true
        }
    });

    const emit = defineEmits<{
        (event: "update:filterValue", value: unknown | undefined): void,
        (event: "update:sortDirection", value: number): void
    }>();

    const internalFilterValue = ref(props.filterValue);
    const sortDirection = useVModelPassthrough(props, "sortDirection", emit);
    const isFilterVisible = ref(false);
    const filterElement = ref<HTMLElement | null>(null);
    const filterButtonElement = ref<HTMLElement | null>(null);
    const resizeHandleElement = ref<HTMLElement | null>(null);
    const columnHeaderElement = ref<HTMLElement | null>(null);
    let resizePositionX = 0;
    let resizeWidth = 0;

    const hasFilter = computed((): boolean => {
        return props.column.filter !== undefined && isFilteringEnabled.value;
    });

    const isSortingEnabled = computed((): boolean => {
        return !props.grid.columns.some(c => c.name === "__reorder");
    });

    const isFilteringEnabled = computed((): boolean => {
        return !props.grid.columns.some(c => c.name === "__reorder");
    });

    const buttonCssClass = computed((): string => {
        return internalFilterValue.value !== undefined ? "btn-grid-column-filter active" : "btn-grid-column-filter";
    });

    const isSortAscending = computed((): boolean => {
        return sortDirection.value > 0 && isSortingEnabled.value;
    });

    const isSortDescending = computed((): boolean => {
        return sortDirection.value < 0 && isSortingEnabled.value;
    });

    const additionalHeaderClass = computed((): string | undefined => props.column.headerClass);

    const titleClass = computed((): string => {
        let classValue = "grid-column-title";

        if (isSortingEnabled.value) {
            classValue += " clickable";
        }

        return classValue;
    });

    const onMouseDownEvent = (ev: MouseEvent): void => {
        if (ev.target && ev.target instanceof HTMLElement) {
            if (filterElement.value && filterElement.value.contains(ev.target)) {
                return;
            }

            if (filterButtonElement.value && filterButtonElement.value.contains(ev.target)) {
                return;
            }
        }

        isFilterVisible.value = false;
        internalFilterValue.value = props.filterValue;
    };

    const onFilterClick = (): void => {
        isFilterVisible.value = !isFilterVisible.value;
    };

    const onFilterClearClick = (): void => {
        isFilterVisible.value = false;
        internalFilterValue.value = undefined;
        emit("update:filterValue", internalFilterValue.value);
    };

    const onFilterApplyClick = (): void => {
        isFilterVisible.value = false;
        emit("update:filterValue", internalFilterValue.value);
    };

    const onResizeMouseDown = (e: MouseEvent): void => {
        if (!columnHeaderElement.value) {
            return;
        }

        resizePositionX = e.pageX;
        resizeWidth = columnHeaderElement.value.clientWidth;

        document.body.addEventListener("mousemove", onResizeMouseMove);
        document.body.addEventListener("mouseup", onResizeMouseUp);
    };

    const onResizeMouseUp = (): void => {
        document.body.removeEventListener("mousemove", onResizeMouseMove);
        document.body.removeEventListener("mouseup", onResizeMouseUp);
    };

    const onResizeMouseMove = (e: MouseEvent): void => {
        if (!columnHeaderElement.value) {
            return;
        }

        const changeAmount = resizePositionX - e.pageX;

        columnHeaderElement.value.style.width = `${resizeWidth - changeAmount}px`;
    };

    const onSortClick = (): void => {
        if (!isSortingEnabled.value) {
            return;
        }

        if (sortDirection.value > 0) {
            sortDirection.value = -1;
        }
        else {
            sortDirection.value = 1;
        }
    };

    watch(isFilterVisible, () => {
        if (isFilterVisible.value) {
            document.addEventListener("mousedown", onMouseDownEvent);

            nextTick(() => {
                // Hack until this is handled by a filter component.
                filterElement.value?.querySelector("input")?.focus();
            });
        }
        else {
            document.removeEventListener("mousedown", onMouseDownEvent);
        }
    });

    watch(resizeHandleElement, () => {
        if (!resizeHandleElement.value) {
            return;
        }

        resizeHandleElement.value.addEventListener("mousedown", onResizeMouseDown);
    });
</script>
