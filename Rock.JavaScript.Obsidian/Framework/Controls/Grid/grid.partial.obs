<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <table class="grid-table table table-bordered table-striped table-hover table-obsidian" :class="{ 'table-sticky': props.stickyHeader }">
        <thead>
            <FilterHeaderRow v-model:filterValue="quickFilterValue"
                             :grid="gridState"
                             :enableFiltering="!reorderColumn"
                             :gridActions="gridActions"
                             :visibleColumnCount="visibleColumnCount" />

            <ColumnHeaderRow :columns="visibleColumnDefinitions"
                             v-model:columnFilters="columnFilterValues"
                             v-model:columnSort="columnSortDirection"
                             :rows="gridState.rows"
                             :grid="gridState" />
        </thead>

        <tbody v-if="dragOptions" v-dragSource="dragOptions" v-dragTarget="dragOptions">
            <DataRows
                      :columns="visibleColumnDefinitions"
                      :rows="visibleRows"
                      :grid="gridState"
                      :tooltipField="tooltipField" />
        </tbody>

        <tbody v-else>
            <tr v-if="loadingData">
                <td class="grid-error" :colspan="visibleColumnCount">
                    <LoadingIndicator />
                </td>
            </tr>

            <tr v-else-if="gridErrorMessage">
                <td class="grid-error" :colspan="visibleColumnCount">
                    <NotificationBox alertType="warning">{{ gridErrorMessage }}</NotificationBox>
                </td>
            </tr>

            <DataRows v-else
                      :columns="visibleColumnDefinitions"
                      :rows="visibleRows"
                      :grid="gridState"
                      :tooltipField="tooltipField" />
        </tbody>

        <tfoot>
            <PagerRow v-model:pageSize="pageSize"
                      v-model:currentPage="currentPage"
                      :pageCount="pageCount"
                      :pageSizes="pageSizes"
                      :message="pagerMessage"
                      :visibleColumnCount="visibleColumnCount"
                      :gridActions="gridActions" />
        </tfoot>
    </table>
</template>

<style>
table.table-obsidian {
    border-collapse: initial;
}

table.table-obsidian.table-sticky > thead {
    position: sticky;
    top: var(--top-header-height);
}

table.table-obsidian th.grid-column-header {
    position: relative;
}

table.table-obsidian th.grid-column-header,
table.table-obsidian th.grid-filter {
    background-color: #f9fafb;
    border-bottom: 1px solid #d3dfe1;
}

table.table-obsidian th.grid-column-header .btn-grid-column-filter {
    border: 0px;
    background-color: transparent;
    margin-left: 4px;
    color: #e7e7e7;
    opacity: 0.5;
    transition-duration: 250ms;
    transition-property: opacity, color;
}

table.table-obsidian th.grid-column-header .btn-grid-column-filter.active {
    color: var(--brand-success);
}

table.table-obsidian th.grid-column-header:hover .btn-grid-column-filter {
    opacity: 1;
}

table.table-obsidian th.grid-column-header .grid-filter-popup {
    position: absolute;
    display: flex;
    flex-direction: column;
    margin-top: 6px;
    min-width: 240px;
    max-width: 320px;
    max-height: 400px;
    background-color: white;
    border: 1px solid #c7c7c7;
    border-radius: 0px;
    border-bottom-right-radius: 6px;
    border-bottom-left-radius: 6px;
    box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
    font-weight: initial;
    z-index: 10;
}

table.table-obsidian th.grid-column-header .grid-filter-popup .grid-filter-popup-content {
    flex-grow: 1;
    overflow-y: auto;
}

table.table-obsidian th.grid-column-header .grid-filter-popup .grid-filter-popup-body {
    margin: 10px;
    padding: 2px;
    overflow-x: clip;
}

table.table-obsidian th.grid-column-header .grid-filter-popup .actions {
    border-top: 1px solid #eee;
    padding: 12px;
}

table.table-obsidian th.grid-column-header .resize-handle {
    position: absolute;
    right: 0px;
    top: 0px;
    bottom: 0px;
    width: 2px;
    height: 100%;
    cursor: w-resize;
}

table.table-obsidian th.grid-column-header:hover .resize-handle {
    background-color: #eee;
}

/* table.table-obsidian td.grid-paging {

} */

table.table-obsidian td.grid-paging .grid-page-sizes {
    flex: 1 0;
    justify-content: start;
    align-items: center;
}

table.table-obsidian td.grid-paging .grid-page-picker {
    flex: 1 0;
    display: flex;
    justify-content: center;
    align-items: center;
}

table.table-obsidian td.grid-paging .grid-page-picker > button {
    border: 0px;
    background-color: transparent;
    margin: 0px 5px;
    padding: 0px 6px;
}

table.table-obsidian td.grid-paging .grid-page-picker > button.disabled {
    opacity: 0.5;
    pointer-events: none;
}

table.table-obsidian td.grid-paging .grid-page-picker > button.active {
    border: 1px solid #b7b7b7;
    background-color: #f7f7f7;
}

table.table-obsidian td.grid-paging .grid-actions {
    flex: 1 0;
    display: flex;
    justify-content: end;
    align-items: center;
}

table.table-obsidian th.grid-filter {
    padding: 8px;
    font-weight: initial;
}

table.table-obsidian th.grid-filter .grid-title {
    flex: 1 0;
    align-self: center;
    font-size: 18px;
}

table.table-obsidian th.grid-filter .grid-quick-filter {
    display: flex;
}

table.table-obsidian th.grid-filter .grid-quick-filter .grid-quick-filter-search {
    max-width: 240px;
    overflow: hidden;
    transition: width 0.3s ease;
}

table.table-obsidian th.grid-filter .grid-actions {
    display: flex;
    justify-content: end;
    background-color: initial;
}

table.table-obsidian th.grid-error {
    padding: 0px;
}

table.table-obsidian th.grid-error > .alert {
    margin-bottom: 0px;
}
</style>

<script setup lang="ts">
    import NotificationBox from "@Obsidian/Controls/notificationBox.obs";
    import LoadingIndicator from "@Obsidian/Controls/loadingIndicator";
    import ColumnHeaderRow from "./columnHeaderRow.partial.obs";
    import DataRows from "./dataRows.partial.obs";
    import FilterHeaderRow from "./filterHeaderRow.partial.obs";
    import PagerRow from "./pagerRow.partial.obs";
    import { computed, PropType, ref, useSlots, watch } from "vue";
    import { asFormattedString } from "@Obsidian/Utility/numberUtils";
    import { pluralConditional } from "@Obsidian/Utility/stringUtils";
    import { getColumnDefinitions, getEntitySetBag, GridActionUrlKey, GridState, GridCommunicationBag } from "@Obsidian/Core/Controls/grid";
    import { DragSource as vDragSource, DragTarget as vDragTarget, IDragSourceOptions, useDragReorder } from "@Obsidian/Directives/dragDrop";
    import { ColumnSort, GridAction, ColumnDefinition, EntitySetOptions } from "@Obsidian/Types/Controls/grid";
    import { GridDataBag } from "@Obsidian/ViewModels/Core/Grid/gridDataBag";
    import { GridDefinitionBag } from "@Obsidian/ViewModels/Core/Grid/gridDefinitionBag";
    import { Guid } from "@Obsidian/Types";
    import { isPromise } from "@Obsidian/Utility/promiseUtils";
    import { useInvokeBlockAction } from "@Obsidian/Utility/block";
    import { makeUrlRedirectSafe } from "@Obsidian/Utility/url";
    import { EntityType } from "@Obsidian/SystemGuids/entityType";
    import { alert } from "@Obsidian/Utility/dialogs";

    /*
     * 8/17/2022 - DSH
     *
     * The grid uses a number of non-ref instances with calculations via function call.
     * This is because the normal wrapped references that Vue uses dramatically slow
     * down our filtering and sorting processes. For example, filtering over wrapped
     * references of 100,000 rows takes around 600ms. The same 100,000 rows using an
     * unwrapped raw array takes about 40ms.
     */

    const props = defineProps({
        data: {
            type: [Object, Function] as PropType<GridDataBag | (() => GridDataBag | Promise<GridDataBag>)>,
            default: []
        },

        definition: {
            type: Object as PropType<GridDefinitionBag>,
            required: false
        },

        /**
         * Identifies the field that will be used to uniquely identify each
         * row. This is not required but many advanced features of the grid
         * require this to function.
         */
        keyField: {
            type: String as PropType<string>,
            required: false
        },

        /**
         * Identifies the field that will contain the person key. If the grid
         * does not represent Person records then leave this unset.
         */
        personKeyField: {
            type: String as PropType<string>,
            required: false
        },

        /**
         * Specifies the fields to be used to identify communication recipients
         * when using the communicate action. This will take precedence over
         * the personKeyField if both are set.
         */
        communicationRecipientPersonKeyFields: {
            type: Array as PropType<string[]>,
            required: false
        },

        /**
         * Identifies the key that will be used to provide the tooltip text
         * for each row in the Grid. This property is not reactive.
         */
        tooltipField: {
            type: String as PropType<string>,
            required: false
        },

        /**
         * Determines if the grid will monitor for changes in the data of
         * existing rows, new rows and removed rows. Should not be used for
         * grids with more than 1,000 rows. This property is not reactive.
         */
        liveUpdates: {
            type: Boolean as PropType<boolean>,
            required: false
        },

        /** If enabled then the grid will have a sticky header. */
        stickyHeader: {
            type: Boolean as PropType<boolean>,
            default: false
        },

        /**
         * The term that identifies individual rows in the grid. This
         * property is not reactive.
         */
        itemTerm: {
            type: String as PropType<string>,
            required: false
        },

        /**
         * The unique identifier of the entity type that the rows represent.
         */
        entityTypeGuid: {
            type: String as PropType<Guid>,
            required: false
        },

        /**
         * If `true`, then any Person operations will instead be Business
         * operations.
         */
        personAsBusiness: {
            type: Boolean as PropType<boolean>,
            default: false
        },

        /**
         * If `true`, then the merge template operation will operate as if
         * the records are Person records. If they are not then it will not
         * work correctly. This required that personKeyField also be set.
         */
        mergeTemplateAsPerson: {
            type: Boolean as PropType<boolean>,
            default: false
        },

        /**
         * Determines if the bulk update action will be available. If not
         * explicitly set then it will default to enabled if the personKeyField
         * property has been set.
         */
        showBulkUpdate: {
            type: Boolean as PropType<boolean | undefined>,
            default: undefined
        },

        /**
         * Determines if the merge person/business action will be available. If not
         * explicitly set then it will default to enabled if the personKeyField
         * property has been set.
         */
        showPersonMerge: {
            type: Boolean as PropType<boolean | undefined>,
            default: undefined
        },

        /**
         * Determines if the launch workflow action will be available. If not
         * explicitly set then it will default to enabled if the entityTypeGuid
         * and keyField properties have been set.
         */
        showLaunchWorkflow: {
            type: Boolean as PropType<boolean | undefined>,
            default: undefined
        },

        /**
         * Determines if the communicate action will be available. If not
         * explicitly set then it will default to enabled if either the
         * personKeyField or communicationRecipientPersonKeyFields properties
         * have been set.
         */
        showCommunicate: {
            type: Boolean as PropType<boolean | undefined>,
            default: undefined
        },

        /**
         * Determines if the merge template action will be available. If not
         * explicitly set then it will default to being shown. In the future
         * this default state might change.
         */
        showMergeTemplate: {
            type: Boolean as PropType<boolean | undefined>,
            default: undefined
        },

        /**
         * Determines if the export action will be available. If not explicitly
         * set then it will default to being shown. In the future this default
         * state might change.
         */
        showExport: {
            type: Boolean as PropType<boolean | undefined>,
            default: undefined
        },

        /**
         * Any fields that should be included when sending a communication. If
         * a column name matches the field name then the formatted value of
         * the column will be used. Otherwise the raw field value will be used.
         */
        communicationMergeFields: {
            type: Array as PropType<string[]>,
            default: ["expirationDateTime|Expires"]//required: false
        },

        /**
         * The function to call in response to the add button being clicked.
         */
        onAddItem: {
            type: Function as PropType<(() => void | Promise<void>)>,
            required: false
        }
    });

    const slots = useSlots();
    const invokeBlockAction = useInvokeBlockAction();

    const gridState = createGridState();

    const customGridActions = ref<GridAction[]>([]);
    const currentPage = ref(1);
    const pageSize = ref(50);
    const pageSizes = [50, 500, 5000];
    const quickFilterValue = ref("");
    const loadingData = ref(false);
    const gridErrorMessage = ref("");
    const columnFilterValues = ref<Record<string, unknown | undefined>>({});
    const columnSortDirection = ref<ColumnSort | undefined>();
    const visibleRows = ref<Record<string, unknown>[]>([]);
    const pageCount = ref(0);
    const pagerMessage = ref("");
    const visibleColumnDefinitions = ref<ColumnDefinition[]>(gridState.columns);
    const dragOptions = ref<IDragSourceOptions | undefined>();
    const reorderColumn: ColumnDefinition | undefined = gridState.columns.find(c => c.name === "__reorder");

    const visibleColumnCount = computed((): number => {
        return visibleColumnDefinitions.value.length;
    });

    const personKeyField = computed((): string | undefined => {
        return props.personKeyField ?? props.keyField;
    });

    const showMergeTemplate = computed((): boolean => {
        if (!props.definition?.actionUrls?.[GridActionUrlKey.MergeTemplate]) {
            return false;
        }

        return props.showMergeTemplate !== false;
    });

    const showExport = computed((): boolean => {
        return props.showExport !== false;
    });

    const showLaunchWorkflow = computed((): boolean => {
        if (!props.definition?.actionUrls?.[GridActionUrlKey.LaunchWorkflow]) {
            return false;
        }

        if (props.showLaunchWorkflow) {
            return true;
        }
        else if (props.showLaunchWorkflow === false) {
            return false;
        }
        else {
            return !!props.keyField && !!props.entityTypeGuid;
        }
    });

    const showBulkUpdate = computed((): boolean => {
        if (!props.definition?.actionUrls?.[GridActionUrlKey.BulkUpdate]) {
            return false;
        }

        if (props.showBulkUpdate) {
            return true;
        }
        else if (props.showBulkUpdate === false) {
            return false;
        }
        else {
            return !!props.personKeyField && !!props.entityTypeGuid;
        }
    });

    const showMergePerson = computed((): boolean => {
        if (!props.definition?.actionUrls?.[GridActionUrlKey.MergePerson]) {
            return false;
        }

        if (props.personAsBusiness) {
            return false;
        }

        if (props.showPersonMerge) {
            return true;
        }
        else if (props.showPersonMerge === false) {
            return false;
        }
        else {
            return !!props.personKeyField;
        }
    });

    const showMergeBusiness = computed((): boolean => {
        if (!props.definition?.actionUrls?.[GridActionUrlKey.MergeBusiness]) {
            return false;
        }

        if (!props.personAsBusiness) {
            return false;
        }

        if (props.showPersonMerge) {
            return true;
        }
        else if (props.showPersonMerge === false) {
            return false;
        }
        else {
            return !!props.personKeyField;
        }
    });

    const showCommunicate = computed((): boolean => {
        if (!props.definition?.actionUrls?.[GridActionUrlKey.Communicate]) {
            return false;
        }

        if (props.showCommunicate) {
            return true;
        }
        else if (props.showCommunicate === false) {
            return false;
        }
        else {
            return !!props.personKeyField || (props.communicationRecipientPersonKeyFields ?? []).length > 0;
        }
    });

    const gridActions = computed((): GridAction[] => {
        const actions: GridAction[] = [];

        // Append the add action.
        if (props.onAddItem) {
            actions.push({
                handler: props.onAddItem,
                iconCssClass: "fa fa-plus-circle fa-fw",
                buttonCssClass: "btn-add",
                tooltip: "Add a new item."
            });
        }

        // Add the action for Merge Records.
        if (showMergeTemplate.value) {
            actions.push({
                handler: onMergeTemplate,
                iconCssClass: "fa fa-files-o fa-fw",
                tooltip: "Merge Records into Merge Template"
            });
        }

        // Add the action for Export to Excel.
        if (showExport.value) {
            actions.push({
                handler: onExport,
                iconCssClass: "fa fa-table fa-fw",
                tooltip: "Export to Excel"
            });
        }

        // Add the action for Launch Workflow.
        if (showLaunchWorkflow.value) {
            actions.push({
                handler: onLaunchWorkflow,
                iconCssClass: "fa fa-cog fa-fw",
                tooltip: "Launch Workflow"
            });
        }

        // Add the action for Bulk Update.
        if (showBulkUpdate.value) {
            actions.push({
                handler: onBulkUpdate,
                iconCssClass: "fa fa-truck fa-fw",
                tooltip: "Bulk Update"
            });
        }

        // Add the action for Merge Person Records.
        if (showMergePerson.value) {
            actions.push({
                handler: onPersonMerge,
                iconCssClass: "fa fa-users fa-fw",
                tooltip: "Merge Person Records"
            });
        }

        // Add the action for Merge Business Records.
        if (showMergeBusiness.value) {
            actions.push({
                handler: onPersonMerge,
                iconCssClass: "fa fa-sign-in-alt fa-fw",
                tooltip: "Merge Business Records"
            });
        }

        // Add the action for Communicate.
        if (showCommunicate.value) {
            actions.push({
                handler: onCommunicate,
                iconCssClass: "fa fa-comment fa-fw",
                tooltip: "Communicate"
            });
        }

        // Append the custom actions.
        actions.push(...customGridActions.value);

        return actions;
    });

    function createGridState(): GridState {
        const state = new GridState(
            getColumnDefinitions(slots["default"]?.() ?? []),
            props.liveUpdates ?? false,
            props.itemTerm || "item",
            props.entityTypeGuid);

        state.setItemKey(props.keyField);

        return state;
    }

    function updateVisibleRows(): void {
        const startIndex = (currentPage.value - 1) * pageSize.value;

        visibleRows.value = gridState.sortedRows.value.slice(startIndex, startIndex + pageSize.value);
    }

    function updatePageCount(): void {
        pageCount.value = Math.ceil(gridState.filteredRows.value.length / pageSize.value);
    }

    function updatePagerMessage(): void {
        pagerMessage.value = `${asFormattedString(gridState.filteredRows.value.length)} ${pluralConditional(gridState.filteredRows.value.length, `${gridState.itemTerm}`, `${gridState.itemTerm}s`)}`;
    }

    async function updateGridData(): Promise<void> {
        loadingData.value = true;

        if (typeof props.data === "object") {
            const data = props.data;
            gridState.setDataRows(data.rows ?? []);
        }
        else if (typeof props.data === "function") {
            try {
                const data = await props.data();

                gridState.setDataRows(data.rows ?? []);
            }
            catch (error) {
                gridErrorMessage.value = error instanceof Error ? error.message : new String(error).toString();
            }
        }

        if (!gridErrorMessage.value) {
            setupManualOrdering();
        }

        loadingData.value = false;
    }

    function setupManualOrdering(): void {
        if (!reorderColumn) {
            dragOptions.value = undefined;
            return;
        }

        if (reorderColumn && !props.keyField) {
            throw new Error("Re-ordering rows requires each row has a unique key.");
        }

        const dropOperationInProgress = ref(false);
        reorderColumn.data.dropOperationInProgress = dropOperationInProgress;

        dragOptions.value = useDragReorder(visibleRows, async (item, beforeItem) => {
            if (typeof reorderColumn.props.onOrderChanged === "function") {
                const fn = reorderColumn.props.onOrderChanged as (item: Record<string, unknown>, beforeItem: Record<string, unknown> | null, order: number) => void | Promise<void> | boolean | Promise<boolean>;

                dropOperationInProgress.value = true;
                try {
                    const result = fn(item, beforeItem, visibleRows.value.indexOf(item));

                    if (isPromise(result)) {
                        await result;
                    }

                    return result !== false;
                }
                finally {
                    dropOperationInProgress.value = false;
                }
            }
            else {
                return true;
            }
        });
    }

    async function onBulkUpdate(): Promise<void> {
        const url = props.definition?.actionUrls?.[GridActionUrlKey.BulkUpdate];

        if (!personKeyField.value || !url) {
            return;
        }

        const options: EntitySetOptions = {
            entityTypeGuid: EntityType.Person
        };

        await createEntitySetAndRedirect([personKeyField.value], url, options);
    }

    async function onPersonMerge(): Promise<void> {
        let url: string | undefined;

        if (props.personAsBusiness) {
            url = props.definition?.actionUrls?.[GridActionUrlKey.MergeBusiness];
        }
        else {
            url = props.definition?.actionUrls?.[GridActionUrlKey.MergePerson];
        }

        if (!personKeyField.value || !url) {
            return;
        }

        await createEntitySetAndRedirect([personKeyField.value], url, undefined);
    }

    async function onMergeTemplate(): Promise<void> {
        const url = props.definition?.actionUrls?.[GridActionUrlKey.MergeTemplate];

        if (!props.keyField || !url) {
            return;
        }

        if (props.mergeTemplateAsPerson && personKeyField.value) {
            await createEntitySetAndRedirect([personKeyField.value], url, undefined);
        }
        else {
            // Find all columns that aren't special columns and include them in
            // the additional merge fields.
            const mergeColumns: Record<string, string> = {};
            const dataColumns = gridState.columns
                .filter(c => !c.name.startsWith("__"));

            for (const column of dataColumns) {
                mergeColumns[column.name] = `${column.name[0].toUpperCase()}${column.name.substring(1)}`;
            }

            const options: EntitySetOptions = {
                mergeColumns
            };

            await createEntitySetAndRedirect([props.keyField], url, options);
        }
    }

    async function onExport(): Promise<void> {
        // Find all columns that aren't special columns and include them in
        // the additional merge fields.
        const mergeColumns: Record<string, string> = {};
        const dataColumns = gridState.columns
            .filter(c => !c.name.startsWith("__"));

        for (const column of dataColumns) {
            mergeColumns[column.name] = `${column.name[0].toUpperCase()}${column.name.substring(1)}`;
        }

        const options: EntitySetOptions = {
            mergeColumns
        };

        const entitySet = await getEntitySetBag(gridState, [], options);

        const data: unknown[][] = [];

        // Build the header row.
        const headerRow: string[] = [];
        data.push(headerRow);

        for (const key of Object.keys(mergeColumns)) {
            const column = gridState.columns.find(c => c.name === key);

            headerRow.push(column?.title ?? key);
        }

        // Build the data rows.
        for (const item of (entitySet.items ?? [])) {
            const row: unknown[] = [];

            for (const key of Object.keys(mergeColumns)) {
                const value = item.additionalMergeValues?.[mergeColumns[key]];

                row.push(value);
            }

            data.push(row);
        }

        // Generate the excel file and initiate the download.
        const xlsx = (await import("@Obsidian/Libs/xlsx"));
        const worksheet = xlsx.utils.aoa_to_sheet(data);
        const workbook = xlsx.utils.book_new();
        xlsx.utils.book_append_sheet(workbook, worksheet, "Sheet 1");
        xlsx.writeFile(workbook, "export.xlsx", { compression: true });
    }

    async function onLaunchWorkflow(): Promise<void> {
        const url = props.definition?.actionUrls?.[GridActionUrlKey.LaunchWorkflow];

        if (!props.keyField || !url) {
            return;
        }

        await createEntitySetAndRedirect([props.keyField], url, undefined);
    }

    async function onCommunicate(): Promise<void> {
        const url = props.definition?.actionUrls?.[GridActionUrlKey.Communicate];
        let keyFields: string[] = [];

        if (props.communicationRecipientPersonKeyFields) {
            keyFields = props.communicationRecipientPersonKeyFields;
        }
        else if (props.personKeyField) {
            keyFields = [props.personKeyField];
        }

        if (keyFields.length === 0 || !url) {
            return;
        }

        const options: EntitySetOptions = {
            additionalMergeFieldsFactory: undefined,
            purpose: "communication"
        };

        options.mergeColumns = {};
        options.mergeFields = {};
        const mergeFields: string[] = [];

        if (props.communicationMergeFields) {
            for (const mf of props.communicationMergeFields) {

                const parts = mf.split("|")
                    .map(f => f.replace(/\./g, "_"))
                    .filter(f => f !== "");

                if (gridState.columns.some(c => c.name === parts[0])) {
                    options.mergeColumns[parts[0]] = parts.length >= 2 ? parts[1] : parts[0];
                }
                else {
                    options.mergeFields[parts[0]] = parts.length >= 2 ? parts[1] : parts[0];
                }

                mergeFields.push(parts.length >= 2 ? parts[1] : parts[0]);
            }
        }

        const entitySet = await getEntitySetBag(gridState, keyFields, options);

        const communicationBag: GridCommunicationBag = {
            recipients: entitySet.items,
            fromUrl: window.location.href
        };

        if (props.communicationRecipientPersonKeyFields) {
            communicationBag.mergeFields = [`AdditionalMergeFields|${mergeFields.join("^")}`];
        }
        else {
            communicationBag.mergeFields = mergeFields;
        }

        await createCommunicationAndRedirect(communicationBag, url);
    }

    async function createCommunicationAndRedirect(communicationBag: GridCommunicationBag, url: string): Promise<void> {
        const args = {
            communication: communicationBag
        };

        const result = await invokeBlockAction<Guid>("CreateGridCommunication", args);

        if (!result.isSuccess || !result.data) {
            return await alert(result.errorMessage || "Unable to create entity set.");
        }

        const finalUrl = makeUrlRedirectSafe(url.replace("{CommunicationId}", `${result.data}`));

        window.location.href = finalUrl;
    }

    async function createEntitySetAndRedirect(keyFields: string[], url: string, options: EntitySetOptions | undefined): Promise<void> {
        const entitySet = await getEntitySetBag(gridState, keyFields, options);
        const args = {
            entitySet
        };

        const result = await invokeBlockAction<Guid>("CreateGridEntitySet", args);

        if (!result.isSuccess || !result.data) {
            return await alert(result.errorMessage || "Unable to create entity set.");
        }

        const finalUrl = makeUrlRedirectSafe(url.replace("{EntitySetId}", `${result.data}`));

        window.location.href = finalUrl;
    }

    watch([quickFilterValue, columnFilterValues], () => {
        currentPage.value = 1;
        gridState.setFilters(quickFilterValue.value, columnFilterValues.value);
    });

    watch(columnSortDirection, () => {
        gridState.setSort(columnSortDirection.value);
    });

    watch([currentPage, pageSize], () => {
        updateVisibleRows();
    });

    watch(() => props.keyField, () => {
        gridState.setItemKey(props.keyField);
    });

    watch(gridState.sortedRows, () => {
        updateVisibleRows();
        updatePageCount();
        updatePagerMessage();
    });

    updateGridData();
</script>
